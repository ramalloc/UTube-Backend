-> Here we are taking images from user So we upload those images on third party Storage :- AWS or Cloudnery. But before uploading those 
    images on cloud we Store them on our server temporarly for utilising those data in case of any connection loss to send the images on 
    cloud.
-> To store temporary images on server we make a folder for that called :- {temp} which is inside of {public} folder. Now git cannot push
    the empty folders on github, So to upload the {temp} folder on server so that temporary images can be stored in the temp folder in 
    future. Therefore we make file of {.gitkeep} which is empty, It is helpful in tracking these types of Util Folders.

-> Now we will make {.gitignore} and those files which should not be upload on git. In market we habe ..gitignore generator which consists
    predefined .gitignore files according to the project/Tech Stack, like here we have-{https://mrkandreev.name/snippets/gitignore-generator/}
    We just need to copy and paste it in .gitignore file and we can add from our side as well.

-> Now we will make .env file

-> Now to organise our file we make src folder, then we make app.js, constants.js, index.js files in src.
-> After that we will make some folders in src :- 
    controller - It includes functionalities majorally, db - It consists database connectivity configurations, 
    middlewares - They are the codes which we want to run in b/w, like checking the request b/w client and server,
    models, routes, utils - It consists the repeated functions which are used consecutively / again an again in different files. 
-> When we make project with team then there is high chance that the code can show conflicts because different style of code which creates
    issue while merging the code on github. So the formatting of code should be same and consistent. Therefore we use {prettier} as library,
    the formatting can be changed as every project requirements therefore we can use prettier generator tools as well.
    After installing the prettier we have to include some files manually, First we have to make a file {.prettierrc} in src folder, It is 
    configuration file of prettier like :- comma, semicolon etc. details. Second file we make is {.prettierignore}, It consists those
    file names where we don't want to implement the prettier.




----> Database Connection
-> We will add mongodb url and other env in .env file, we don't need '/' in last of mongodb url.
-> Now we will add and export our Database name in constants.js file as DB_NAME = "UTubeDB"
-> There are two ways to connnect databse :- 1st is that we can add database connection code in index.js, so when index.js executed our
    database connection also executed.
    2nd method is we make different file for database connection code and we will import that file in index.js.
-> We need dotenv, mongoose and express, so we install it.
-> So first we will use mongoose to make connection with mongodb. 
**-> Whenever we try to communicate with database there is high chance that problems can occurs. Therefore we should wrap it in try-catch
    or in promises.
**-> "Our Database is always in other Continent", means it takes time to communicate with database therefore we use asyn-await always.

-- 1st Appraoch --
-> Here we are writing the database connection code using IIFEs - A JavaScript IIFE (Immediately Invoked Function Expression)
    is a function that runs the moment it is invoked or called in the JavaScript event loop.
-> We should always write ';' before IIFE because it is possible that previous doesn't have semicolon which may occurs error.
-> Then we wil wrap code in async and in try-catch, We have to add DB_NAME also after DB_URL/
-> Sometimes Programmers implement express in index.js file, They add listeners rigth after database connection.


-- 2nd Approach -- 
-> We make a file in db folder and implement the database connection code there, Here We will make a function and export that.
-> We are using process.exit() in error handling - Calling process.exit() will force the process to exit as quickly as possible even if 
    there are still asynchronous operations pending that have not yet completed fully, including I/O operations to process.stdout 
    and process.stderr. In most situations, it is not actually necessary to call process.exit()explicitly.
    The Node.js process will exit on its own if there is no additional work pending in the event loop.
    The process.exitCode property can be set to tell the process which exit code to use when the process exits gracefully.
-> Production, developement and testing have different databases, So {connectionInstance.connection.host} gives the name of host connected. 

-- Setting Dotenv --
-> As early as possible in your application, import and configure dotenv. We should add in index.js which loads first on server
    we should add dotenv first and configure. But dotenv adding method disrupt our consistency of importing because it uses require.
    So here we have to import it then have to configure it as well, takes path of .env file in configuration.
-> We can use import dotenv as experimental feature, we have to write some commands in "dev" packagae.json after "nodemon" to load 
    all dotenv configurations but at this time we have to load it as experimental feature.


-- Setting Express --
-> We initialize the express in app.js and export it. We import app.js in index.js, connectDB is an async function therefore it returns 
    promise. In index.js after calling connectDB() we get promise so we use then() and catch() for Immediate initialization of express/app
    listener.
-> We mainly work in express on request and response. Most used is - req.params which consists the info comes from url, 
    req.body consists data in forms or json etc, req.cookies used to store or retrieve data in user's browser used by middleware .
    So we have to install cookie-parser and cors, Whenever we use middlewares we write it's syntax as using express's app 
    {app.use(_middleware_)}.
-> After installing of cors and cookie parser we import them in app.js, Now we have to configure them after executing app.
    We can configure more in cors, it contains some options which gives contains the accessbility options. We can define origin in options
    and status as well. In origin we set .env as CORS_ORIGIN Which we have to set in .env file, We set CORS_ORIGIN = * means anyone can 
    access but we can add vercel, netlify etc as well.
-> We can get data from url, json, req-body, direct-form, json-form. So it needs some settings like limitation of incoming json data to 
    prevent from server crash. Now we can configure json with express, Common optionis {express.json({limit:"16kb"})}.
    Before express version needs middlewares like body-parser to accept can configure json data.
-> Now we have to configure the datas whose are coming from url, Express gives one more direct configuration to encode the url 
    {express.urlencoded()} it is sufficient but it also contains some option like "extended", "limit" {express.urlencoded(extended: true, limit: "16kb")}
    which is used to give objects in objects means helps in nesting of objects.
-> Another express configuration that we will use is :- static to keep/store file, images, fevicon in public as public asset anyone can 
    access them.

-> Cooie Parse helps in accessing ans setting the cookies in user's browser by server, means performing CRUD operation on user's browser's
    coockies. It also helps in to keep secure coockies in browser by server only. Now we configure the cookieParser in app.js.
    


--> middleware - the function/code which checks the request or response of client or server is called middleware. When an api hit
    it contains (err, req, res, next), Whenever we used next it means that is middleware. {next} is a flag, when middleware code segment
    completed its task then it forwards to the next middleware using {next} flag. If there is no next middleware in code segment then 
    it discard the process or done with the process. The arrangement of middleware is also important.



-- Database Wrapper --
-> we will communicate with database again and again in user's, video's controller. So we should make an utility file which contains
    wrapper. Wrapper takes function as method and peforms its operation.
-> We make a asyncHandler.js utile file. It contains a  higer order funciton which takes a function as parameter and returns function as well.
    It treats a function as higher order funciton.
-> We can implement higher order by two methods usuing async try-catch and Promises.
-> In try-catch method We take (req, res, next) as parameter, taking {next} because we can use it as middleware in future. Then we will implement try-catch.
    we handle the error by sending response as error code (if user send err code else we send customised err code ) and error message 
    using json.
-> In promise method we take the function and return it in the form of promise.


-- Error Handling --
-> When we are returning the error in response and we will send this many times. We don't have any structure or centralize standard to send 
    error. Now we want to standardize the api response and api's error as well which leads to the standard codebase.
-> So we have an error class in NodeJs, which contains some functions and constructors We can change them in different extended class.
    We make a file apiError.js in Utils Folder, We make a class ApiError which is inherited from Error class of NodeJs.
    We will take the constructor and then we will overwrite then constructor as well. Now whoever use the apiError class they have to 
    give some data which is defined in constructor. 

-- Api Response Handling -- 
-> We can trace error in NodeJs but for response we are using Express library. So we make a file to streamline the API Response.
-> We make a file apiResponse which consists class of ApiResponse. Whenever we send response we send them through this class/file.
    We set the default data in constructor that it needs like:- statusCode, message and data. We can overwrite them according to data.
    We have to set success = statusCode < 400, according to the standards.

--> Now we want that whenever there is an error occurs, the error should go throgh the apiError means we have to write middlewares.



